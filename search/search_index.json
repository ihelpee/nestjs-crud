{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"In\u00edcio","text":""},{"location":"#why","title":"Why?","text":"<p>NestJS is probably one of the best things that happened to Node.js community a couple of years ago. It was a missing part that provides a truly important architectural solution for a wide range of backend development aspects. But, despite the fact that it allows creating RESTful applications efficiently, an important CRUD scaffolding functionality that is present in many other HTTP frameworks was missing. That's why Ihelpee/crud came out. And we hope you'll find it very useful.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>yarn add @ihelpee/crud-typeorm @nestjs/typeorm typeorm\n</code></pre> <p>For for TypeORM 0.2.x :</p> <pre><code>yarn add @ihelpee/crud-typeorm@~5.1 @nestjs/typeorm@~8.0.2 typeorm@~0.2\n</code></pre>"},{"location":"#compatibility","title":"Compatibility","text":"<p>Versions &lt; 5.2.0 aim for full compatibility with the original nestjsx/crud project while adding a few new features.</p> <p>Version &gt;= 5.2.0 is based on TypeORM 0.3.x and might not be compatible, but still the goal is to have minimal disruption when upgrading from TypeORM 0.2.x</p>"},{"location":"#documentation","title":"Documentation","text":""},{"location":"#controllers","title":"Controllers","text":"<ul> <li>Description</li> <li>Install</li> <li>Getting started</li> <li>API endpoints</li> <li>Swagger</li> <li>Options</li> <li>Global options</li> <li>Request authentication</li> <li>Request validation</li> <li>Response serialization</li> <li>IntelliSense</li> <li>Routes override</li> <li>Adding routes</li> <li>Additional decorators</li> </ul>"},{"location":"#services","title":"Services","text":"<ul> <li>Description</li> <li>TypeORM</li> </ul>"},{"location":"#requests","title":"Requests","text":"<ul> <li>Description</li> <li>Query params</li> <li>Frontend usage</li> </ul>"},{"location":"about/","title":"About","text":"<p>This is a fork of @nestjsx/crud , the aim is to maintain compatibility with the original project while supporting new features and keeping it up to date .</p>"},{"location":"controllers/","title":"Controllers","text":""},{"location":"controllers/#description","title":"Description","text":"<p>@ihelpee/crud - core package which provides <code>@Crud()</code> controller decorator for endpoints generation, global configuration, validation, helper decorators.</p>"},{"location":"controllers/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Install</li> <li>Getting started</li> <li>API endpoints</li> <li>Swagger</li> <li>Options</li> <li>model</li> <li>validation</li> <li>params</li> <li>routes</li> <li>query</li> <li>dto</li> <li>serialize</li> <li>Global options</li> <li>Request authentication</li> <li>Request validation</li> <li>Response serialization</li> <li>IntelliSense</li> <li>Routes override</li> <li>Adding routes</li> <li>Additional decorators</li> </ul>"},{"location":"controllers/#install","title":"Install","text":"<pre><code>yarn add @ihelpee/crud class-transformer class-validator\n</code></pre>"},{"location":"controllers/#using-typeorm","title":"Using TypeORM","text":"<pre><code>yarn add @ihelpee/crud-typeorm @nestjs/typeorm typeorm\n</code></pre>"},{"location":"controllers/#getting-started","title":"Getting started","text":"<p>Let's take a look at the example of using <code>@ihelpee/crud</code> with TypeORM.</p> <p>Assume we have some TypeORM entity:</p> <pre><code>import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';\n\n@Entity()\nexport class Company {\n  @PrimaryGeneratedColumn() id: number;\n\n  @Column() name: string;\n}\n</code></pre> <p>Then we need to create a service:</p> <pre><code>import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { TypeOrmCrudService } from '@ihelpee/crud-typeorm';\n\nimport { Company } from './company.entity';\n\n@Injectable()\nexport class CompaniesService extends TypeOrmCrudService&lt;Company&gt; {\n  constructor(@InjectRepository(Company) repo) {\n    super(repo);\n  }\n}\n</code></pre> <p>We've done with the service so let's create a controller:</p> <pre><code>import { Controller } from '@nestjs/common';\nimport { Crud, CrudController } from '@ihelpee/crud';\n\nimport { Company } from './company.entity';\nimport { CompaniesService } from './companies.service';\n\n@Crud({\n  model: {\n    type: Company,\n  },\n})\n@Controller('companies')\nexport class CompaniesController implements CrudController&lt;Company&gt; {\n  constructor(public service: CompaniesService) {}\n}\n</code></pre> <p>All we have to do next is to connect our service and controller in the <code>CompaniesModule</code> as we usually do:</p> <pre><code>import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { Company } from './company.entity';\nimport { CompaniesService } from './companies.service';\nimport { CompaniesController } from './companies.controller';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([Company])],\n  providers: [CompaniesService],\n  exports: [CompaniesService],\n  controllers: [CompaniesController],\n})\nexport class CompaniesModule {}\n</code></pre> <p>That's it.</p>"},{"location":"controllers/#api-endpoints","title":"API Endpoints","text":"<p><code>Crud()</code> decorator generates the following API endpoints:</p>"},{"location":"controllers/#get-many-resources","title":"Get many resources","text":"<p><code>GET /heroes</code> &gt; <code>GET /heroes/:heroId/perks</code></p> <p>Result: array of resources | pagination object with data Status Codes: 200</p>"},{"location":"controllers/#get-one-resource","title":"Get one resource","text":"<p><code>GET /heroes/:id</code> &gt; <code>GET /heroes/:heroId/perks:id</code></p> <p>Request Params: <code>:id</code> - some resource field (slug) Result: resource object | error object Status Codes: 200 | 404</p>"},{"location":"controllers/#create-one-resource","title":"Create one resource","text":"<p><code>POST /heroes</code> &gt; <code>POST /heroes/:heroId/perks</code></p> <p>Request Body: resource object | resource object with nested (relational) resources Result: created resource object | error object Status Codes: 201 | 400</p>"},{"location":"controllers/#create-many-resources","title":"Create many resources","text":"<p><code>POST /heroes/bulk</code> &gt; <code>POST /heroes/:heroId/perks/bulk</code></p> <p>Request Body: array of resources objects | array of resources objects with nested (relational) resources</p> <pre><code>{\n  \"bulk\": [{ \"name\": \"Batman\" }, { \"name\": \"Batgirl\" }]\n}\n</code></pre> <p>Result: array of created resources | error object Status codes: 201 | 400</p>"},{"location":"controllers/#update-one-resource","title":"Update one resource","text":"<p><code>PATCH /heroes/:id</code> &gt; <code>PATCH /heroes/:heroId/perks/:id</code></p> <p>Request Params: <code>:id</code> - some resource field (slug) Request Body: resource object (or partial) | resource object with nested (relational) resources (or partial) Result:: updated partial resource object | error object Status codes: 200 | 400 | 404</p>"},{"location":"controllers/#replace-one-resource","title":"Replace one resource","text":"<p><code>PUT /heroes/:id</code> &gt; <code>PUT /heroes/:heroId/perks/:id</code></p> <p>Request Params: <code>:id</code> - some resource field (slug) Request Body: resource object | resource object with nested (relational) resources (or partial) Result:: replaced resource object | error object Status codes: 200 | 400</p>"},{"location":"controllers/#delete-one-resource","title":"Delete one resource","text":"<p><code>DELETE /heroes/:id</code> &gt; <code>DELETE /heroes/:heroId/perks/:id</code></p> <p>Request Params: <code>:id</code> - some resource field (slug) Result:: empty | resource object | error object Status codes: 200 | 404</p>"},{"location":"controllers/#swagger","title":"Swagger","text":"<p>Swagger support is present out of the box.</p>"},{"location":"controllers/#options","title":"Options","text":"<p><code>Crud()</code> decorator accepts the following <code>CrudOptions</code>:</p>"},{"location":"controllers/#model","title":"model","text":"<pre><code>@Crud({\n  model: {\n    type: Entity|Model|DTO\n  },\n  ...\n})\n</code></pre> <p>Required</p> <p><code>Entity</code>, <code>Model</code> or <code>DTO</code> class must be provided here. Everything else described bellow is optional. It's needed for a built in validation based on NestJS <code>ValidationPipe</code>.</p>"},{"location":"controllers/#validation","title":"validation","text":"<pre><code>@Crud({\n  ...\n  validation?: ValidationPipeOptions | false;\n  ...\n})\n</code></pre> <p>Optional</p> <p>Accepts <code>ValidationPipe</code> options or <code>false</code> if you want to use your own validation implementation.</p>"},{"location":"controllers/#params","title":"params","text":"<pre><code>@Crud({\n  ...\n  params?: {\n    [key: string]: {\n      field: string;\n      type: 'number' | 'string' | 'uuid';\n      primary?: boolean;\n      disabled?: boolean;\n    },\n  },\n  ...\n})\n</code></pre> <p>Optional</p> <p>By default <code>@Crud()</code> decorator will use <code>id</code> with the type <code>number</code> as a primary slug param.</p> <p>If you have, for instance, a resorce field called <code>slug</code> or whatever, it's a UUID and you need it to be a primary slug by which your resource should be fetched, you can set up this params options:</p> <pre><code>@Crud({\n  // ...\n  params: {\n    slug: {\n      field: 'slug',\n      type: 'uuid',\n      primary: true,\n    },\n  },\n  // ...\n})\n</code></pre> <p>If you have a controller path with that looks kinda similar to this <code>/companies/:companyId/users</code> you need to add this param option:</p> <pre><code>@Crud({\n  ...\n  params: {\n    ...\n    companyId: {\n      field: 'companyId',\n      type: 'number'\n    },\n  },\n  ...\n})\n</code></pre> <p>Also, you can disable <code>id</code> param if you want to have only few routs without any path params. It's very useful, for creating something like <code>GET /me</code> endpoints.</p> <pre><code>@Crud({\n  model: {\n    type: User,\n  },\n  routes: {\n    only: ['getOneBase', 'updateOneBase'],\n  },\n  params: {\n    id: {\n      primary: true,\n      disabled: true,\n    },\n  },\n  query: {\n    join: {\n      company: {\n        eager: true,\n      },\n      profile: {\n        eager: true,\n      },\n    },\n  },\n})\n@CrudAuth({\n  property: 'user',\n  filter: (user: User) =&gt; ({\n    id: user.id,\n  }),\n})\n@Controller('me')\nexport class MeController {\n  constructor(public service: UsersService) {}\n}\n</code></pre>"},{"location":"controllers/#routes","title":"routes","text":"<pre><code>@Crud({\n  ...\n  routes?: {\n    exclude?: BaseRouteName[],\n    only?: BaseRouteName[],\n    getManyBase?: {\n      interceptors?: [],\n      decorators?: [],\n    },\n    getOneBase?: {\n      interceptors?: [],\n      decorators?: [],\n    },\n    createOneBase?: {\n      interceptors?: [],\n      decorators?: [],\n      returnShallow?: boolean;\n    },\n    createManyBase?: {\n      interceptors?: [],\n      decorators?: [],\n    },\n    updateOneBase: {\n      interceptors?: [],\n      decorators?: [],\n      allowParamsOverride?: boolean,\n      returnShallow?: boolean;\n    },\n    replaceOneBase: {\n      interceptors?: [],\n      decorators?: [],\n      allowParamsOverride?: boolean,\n      returnShallow?: boolean;\n    },\n    deleteOneBase?: {\n      interceptors?: [],\n      decorators?: [],\n      returnDeleted?: boolean,\n    },\n  },\n  ...\n})\n</code></pre> <p>Optional</p> <p>It's a set of options for each of the generated routes.</p> <p><code>interceptors</code> - an array of your custom interceptors <code>decorators</code> - an array of your custom decorators <code>allowParamsOverride</code> - whether or not to allow body data be overriten by the URL params on PATH request. Default: <code>false</code> <code>returnDeleted</code> - whether or not an entity object should be returned in the response body on DELETE request. Default: <code>false</code> <code>returnShallow</code> - whether or not to return a shallow entity</p> <p>Also you can specify what routes should be excluded or what routes whould be used only by providing routes names to the <code>exclude</code> or <code>only</code> accordingly.</p>"},{"location":"controllers/#query","title":"query","text":"<pre><code>@Crud({\n  ...\n  query?: {\n    allow?: string[];\n    exclude?: string[];\n    persist?: string[];\n    filter?: QueryFilterOption;\n    join?: JoinOptions;\n    sort?: QuerySort[];\n    limit?: number;\n    maxLimit?: number;\n    cache?: number | false;\n    alwaysPaginate?: boolean;\n    softDelete?: boolean;\n  },\n  ...\n})\n</code></pre> <p>Optional</p> <p>It's a set of query options for GET request.</p>"},{"location":"controllers/#allow","title":"allow","text":"<pre><code>{\n  allow: ['name', 'email'];\n}\n</code></pre> <p>Optional</p> <p>An Array of fields that are allowed to be received in GET requests. If empty or undefined - allow all.</p>"},{"location":"controllers/#exclude","title":"exclude","text":"<pre><code>{\n  exclude: ['accessToken'];\n}\n</code></pre> <p>Optional</p> <p>An Array of fields that will be excluded from the GET response (and not queried from the DB).</p>"},{"location":"controllers/#persist","title":"persist","text":"<pre><code>{\n  persist: ['createdAt'];\n}\n</code></pre> <p>Optional</p> <p>An Array of fields that will be always persisted in GET response.</p>"},{"location":"controllers/#filter","title":"filter","text":"<p>Optional</p> <p>This option can be used in two scenarios:</p> <ol> <li>If you want to add some conditions to the request:</li> </ol> <pre><code>{\n  filter: {\n    isActive: {\n      $ne: false;\n    }\n  }\n}\n</code></pre> <p>...which is the same as:</p> <pre><code>{\n  filter: [\n    {\n      field: 'isActive',\n      operator: '$ne',\n      value: false,\n    },\n  ];\n}\n</code></pre> <ol> <li> <p>If you want to transform your query search conditions or event return a completely new one (i.e. persist only one set of conditions and ignore search coming from the request):</p> </li> <li> <p>Totally ignore any query search conditions:</p> </li> </ol> <pre><code>{\n  filter: () =&gt; {};\n}\n</code></pre> <ul> <li>Totally ignore any query search conditions and persist some conditions:</li> </ul> <pre><code>{\n  filter: () =&gt; ({\n    isActive: {\n      $ne: false;\n    }\n  });\n}\n</code></pre> <ul> <li>Transform query search conditions:</li> </ul> <pre><code>import { SCondition } from '@ihelpee/crud-request'\n\n...\n\n{\n  filter: (search: SCondition, getMany: boolean) =&gt; {\n    return getMany ? search : {\n      $and: [\n        ...search.$and,\n        { isActive: true },\n      ],\n    }\n  };\n}\n</code></pre> <p>Notice: First function parameter here, <code>search</code>, will always be either <code>{ $and: [...] }</code> or <code>{ $or: [...] }</code>. It depends on if you're using <code>@CrudAuth()</code> decorator:</p> <ul> <li>if you are not using it, or if you do and it has <code>filter</code> function then <code>search</code> will contain <code>$and</code> type of conditions.</li> <li>if you are using it and it has <code>or</code> function then <code>search</code> will contain <code>$or</code> type of conditions.</li> </ul>"},{"location":"controllers/#join","title":"join","text":"<pre><code>{\n  join: {\n    profile: {\n      persist: ['name'],\n      exclude: ['token'],\n      eager: true,\n      require: true,\n    },\n    tasks: {\n      allow: ['content'],\n    },\n    notifications: {\n      eager: true,\n      select: false,\n    },\n    company: {},\n    'company.projects': {\n      persist: ['status']\n    },\n    'users.projects.tasks': {\n      exclude: ['description'],\n      alias: 'projectTasks',\n    },\n  }\n}\n</code></pre> <p>Optional</p> <p>An Object of relations that allowed to be fetched by passing <code>join</code> query parameter in GET requests.</p> <p>Each key of <code>join</code> object must strongly match the name of the corresponding resource relation. If particular relation name is not present in this option, then user will not be able to get this relational objects in GET request.</p> <p>Each relation option can have (all below are optional):</p> <p><code>allow</code> - an Array of fields that are allowed to be received in GET requests. If empty or undefined - allow all. <code>exclude</code> - an Array of fields that will be excluded from the GET response (and not queried from the DB). <code>persist</code> - an Array of fields that will be always persisted in GET response. <code>eager</code> - type <code>boolean</code> - whether or not current relation should persist in every GET response. <code>require</code> - should a relation be required or not. For RMDBS means use either <code>INNER</code> or <code>LEFT</code> join. Default: <code>false</code>. <code>alias</code> - set alias for a relation. <code>select</code> - type <code>boolean</code> - if <code>false</code> then the relation will be joined but not selected and not included in the response.</p>"},{"location":"controllers/#sort","title":"sort","text":"<pre><code>{\n  sort: [\n    {\n      field: 'id',\n      order: 'DESC',\n    },\n  ];\n}\n</code></pre> <p>Optional</p> <p>An Array of <code>sort</code> objects that will be merged (combined) with query <code>sort</code> if those are passed in GET request. If not - <code>sort</code> will be added to the DB query as a stand-alone condition.</p>"},{"location":"controllers/#limit","title":"limit","text":"<pre><code>{\n  limit: 25,\n}\n</code></pre> <p>Optional</p> <p>Default <code>limit</code> that will be aplied to the DB query.</p>"},{"location":"controllers/#maxlimit","title":"maxLimit","text":"<pre><code>{\n  maxLimit: 100,\n}\n</code></pre> <p>Optional</p> <p>Max amount of results that can be queried in GET request.</p> <p>Notice: it's strongly recommended to set up this option. Otherwise DB query will be executed without any LIMIT if no <code>limit</code> was passed in the query or if the <code>limit</code> option hasn't been set up in crud options.</p>"},{"location":"controllers/#cache","title":"cache","text":"<pre><code>{\n  cache: 2000,\n}\n</code></pre> <p>Optional</p> <p>If <code>Caching Results</code> is implemented on you project, then you can set up default <code>cache</code> in milliseconds for GET response data.</p> <p>Cache can be reseted by using <code>cache=0</code> query parameter in your GET requests.</p>"},{"location":"controllers/#alwayspaginate","title":"alwaysPaginate","text":"<pre><code>{\n  alwaysPaginate: true,\n}\n</code></pre> <p>Optional</p> <p>Either or not always return an object with paginated data. Can be defined globally as well.</p>"},{"location":"controllers/#softdelete","title":"softDelete","text":"<pre><code>{\n  softDelete: true,\n}\n</code></pre> <p>Optional</p> <p>A boolean value indicating whether the item should be soft-deleted. If set to true, the item will be soft-deleted instead of being permanently removed from the database.</p>"},{"location":"controllers/#dto","title":"dto","text":"<pre><code>@Crud({\n  ...\n  dto?: {\n    create?: Type&lt;any&gt;,\n    update?: Type&lt;any&gt;,\n    replace?: Type&lt;any&gt;\n  },\n  ...\n})\n</code></pre> <p>Optional</p> <p>Request body validation DTO classes. If no DTO is provided to any of the option, then a <code>CrudOptions.model.type</code> will be used as described in the Request validation section.</p>"},{"location":"controllers/#serialize","title":"serialize","text":"<pre><code>@Crud({\n  ...\n  serialize?: {\n    getMany?: Type&lt;any&gt; | false;\n    get?: Type&lt;any&gt; | false;\n    create?: Type&lt;any&gt; | false;\n    createMany?: Type&lt;any&gt; | false;\n    update?: Type&lt;any&gt; | false;\n    replace?: Type&lt;any&gt; | false;\n    delete?: Type&lt;any&gt; | false;\n  }\n  ...\n})\n</code></pre> <p>Optional</p> <p>Response serialization DTO classes. Each option also accepts <code>false</code> in order to not perform serialization for particular route.</p> <p>Please see Response serialization section for more details.</p>"},{"location":"controllers/#global-options","title":"Global options","text":"<p>In order to reduce some repetition in your <code>CrudOptions</code> in every controller you can specify some options globally:</p> <pre><code>{\n  queryParser?: RequestQueryBuilderOptions;\n  routes?: RoutesOptions;\n  params?: ParamsOptions;\n  auth?: {\n    property?: string;\n  };\n  query?: {\n    limit?: number;\n    maxLimit?: number;\n    cache?: number | false;\n    alwaysPaginate?: boolean;\n  };\n  serialize?: {\n    getMany?: false;\n    get?: false;\n    create?: false;\n    createMany?: false;\n    update?: false;\n    replace?: false;\n    delete?: false;\n  };\n}\n</code></pre> <p><code>queryParser</code> are options for <code>RequestQueryParser</code> that is being used in <code>CrudRequestInterceptor</code> to parse/validate query and path params. Frontend has similar customization ability.</p> <p><code>routes</code> are the same as here.</p> <p><code>params</code> are the same as here.</p> <p><code>query</code> are similar to options described here except the fact that <code>limit</code>, <code>maxLimit</code>, <code>cache</code>, <code>alwaysPaginate</code> can be applied only.</p> <p><code>serialize</code> allows you to globally disable serialization for particular actions.</p> <p>So in order to apply global options you need load them in your main.ts (index.ts) file BEFORE you import <code>AppModule</code> class. That's because TypeScript decorators are executed when we declare our class but not when we create new class instance. So in your <code>main.ts</code>:</p> <pre><code>import { CrudConfigService } from '@ihelpee/crud';\n\nCrudConfigService.load({\n  query: {\n    limit: 25,\n    cache: 2000,\n  },\n  params: {\n    id: {\n      field: 'id',\n      type: 'uuid',\n      primary: true,\n    },\n  },\n  routes: {\n    updateOneBase: {\n      allowParamsOverride: true,\n    },\n    deleteOneBase: {\n      returnDeleted: true,\n    },\n  },\n});\n\nimport { AppModule } from './app.module';\n\n...\n</code></pre> <p>Notice: all those options can be overridden in each <code>CrudController</code>.</p>"},{"location":"controllers/#request-authentication","title":"Request authentication","text":"<p>In order to perform data filtering for authenticated requests, we provide <code>@CrudAuth()</code> decorator. It accepts these options:</p> <pre><code>{\n  property?: string;\n  filter?: (req: any) =&gt; SCondition | void;\n  or?: (req: any) =&gt; SCondition | void;\n  persist?: (req: any) =&gt; ObjectLiteral;\n}\n</code></pre> <p><code>property</code> - property on the <code>Request</code> object where user's data stored after successful authentication. Can be set globally as well.</p> <p><code>filter</code> - a function that should return search condition and will be added to the query search params and path params as a <code>$and</code> condition:</p> <p><code>{Auth condition} AND {Path params} AND {Search|Filter}</code></p> <p><code>or</code> - a function that should return search condition and will be added to the query search params and path params as a <code>$or</code> condition. If it's used then <code>filter</code> function will be ignored.</p> <p><code>{Auth condition} OR ({Path params} AND {Search|Filter})</code></p> <p><code>persist</code> - a function that can return an object that will be added to the DTO on <code>create</code>, <code>update</code>, <code>replace</code> actions. Useful in case if you need to prevent changing some sensitive entity properties even if it's allowed in DTO validation.</p> <pre><code>@Crud({...})\n@CrudAuth({\n  property: 'user',\n  filter: (user: User) =&gt; ({\n    id: user.id,\n    isActive: true,\n  })\n})\n</code></pre>"},{"location":"controllers/#request-validation","title":"Request validation","text":"<p>Query params and path params validation is performed by an interceptor. It parses query and path parameters and then validates them.</p> <p>Body request validation is done by NestJs <code>ValidationPipe</code>.</p> <p>You can provide either <code>create</code>, <code>update</code>, <code>replace</code> DTO in the <code>CrudOptions.dto</code> options or use the following approach.</p> <p>You can use <code>CrudOptions.model.type</code> as a DTO that describes validation rules. We distinguish body validation on <code>create</code> and <code>update</code> methods. This was achieved by using validation groups.</p> <p>Let's take a look at this example:</p> <pre><code>import { Entity, Column, OneToMany } from 'typeorm';\nimport { IsOptional, IsString, MaxLength, IsNotEmpty } from 'class-validator';\nimport { Type } from 'class-transformer';\nimport { CrudValidationGroups } from '@ihelpee/crud';\n\nimport { BaseEntity } from '../base-entity';\nimport { User } from '../users/user.entity';\nimport { Project } from '../projects/project.entity';\n\nconst { CREATE, UPDATE } = CrudValidationGroups;\n\n@Entity('companies')\nexport class Company extends BaseEntity {\n  @IsOptional({ groups: [UPDATE] })\n  @IsNotEmpty({ groups: [CREATE] })\n  @IsString({ always: true })\n  @MaxLength(100, { always: true })\n  @Column({ type: 'varchar', length: 100, nullable: false })\n  name: string;\n\n  @IsOptional({ groups: [UPDATE] })\n  @IsNotEmpty({ groups: [CREATE] })\n  @IsString({ groups: [CREATE, UPDATE] })\n  @MaxLength(100, { groups: [CREATE, UPDATE] })\n  @Column({ type: 'varchar', length: 100, nullable: false, unique: true })\n  domain: string;\n\n  @IsOptional({ always: true })\n  @IsString({ always: true })\n  @Column({ type: 'text', nullable: true, default: null })\n  description: string;\n\n  /**\n   * Relations\n   */\n\n  @OneToMany((type) =&gt; User, (u) =&gt; u.company)\n  @Type((t) =&gt; User)\n  users: User[];\n\n  @OneToMany((type) =&gt; Project, (p) =&gt; p.company)\n  projects: Project[];\n}\n</code></pre> <p>You can import <code>CrudValidationGroups</code> enum and set up validation rules for each field on firing of <code>POST</code>, <code>PATCH</code> requests or both of them.</p>"},{"location":"controllers/#response-serialization","title":"Response serialization","text":"<p>Serialization is performed using <code>class-transformer</code> package and is already included and turned ON in each route.</p> <p>So in your entity you can use some useful decorators:</p> <pre><code>import { Exclude } from 'class-transformer';\n\nexport class User {\n  email: string;\n\n  @Exclude()\n  password: string;\n}\n</code></pre> <p>But there might be situations when you might need to use different serialization in different routes. In that case you can use <code>CrudOptions.serialize</code> options.</p>"},{"location":"controllers/#intellisense","title":"IntelliSense","text":"<p>Please, keep in mind that we compose crud controllers by the logic inside our <code>@Crud()</code> class decorator. And there are some unpleasant but not very significant side effects of this approach.</p> <p>First, there is no IntelliSense on composed methods. That's why we need to use <code>CrudController</code> interface. This will help to make sure that you're injecting proper <code>CrudService</code>.</p> <p>Second, even after adding <code>CrudController</code> interface you still wouldn't see composed methods, accessible from <code>this</code> keyword, furthermore, you'll get a TS error. In order to solve this, you can do as follows:</p> <pre><code>...\nimport { Crud, CrudController } from '@ihelpee/crud';\n\n@Crud(Hero)\n@Controller('heroes')\nexport class HeroesCrud implements CrudController&lt;Hero&gt; {\n  constructor(public service: HeroesService) {}\n\n  get base(): CrudController&lt;Hero&gt; {\n    return this;\n  }\n}\n</code></pre>"},{"location":"controllers/#routes-override","title":"Routes override","text":"<p>Here is the list of composed base routes methods by <code>@Crud()</code> decorator:</p> <pre><code>{\n  getManyBase(\n    @ParsedRequest() req: CrudRequest,\n  ): Promise&lt;GetManyDefaultResponse&lt;T&gt; | T[]&gt;;\n\n  getOneBase(\n    @ParsedRequest() req: CrudRequest,\n  ): Promise&lt;T&gt;;\n\n  createOneBase(\n    @ParsedRequest() req: CrudRequest,\n    @ParsedBody() dto: T,\n  ): Promise&lt;T&gt;;\n\n  createManyBase(\n    @ParsedRequest() req: CrudRequest,\n    @ParsedBody() dto: CreateManyDto&lt;T&gt;,\n  ): Promise&lt;T&gt;;\n\n  updateOneBase(\n    @ParsedRequest() req: CrudRequest,\n    @ParsedBody() dto: T,\n  ): Promise&lt;T&gt;;\n\n  replaceOneBase(\n    @ParsedRequest() req: CrudRequest,\n    @ParsedBody() dto: T,\n  ): Promise&lt;T&gt;;\n\n  deleteOneBase(\n    @ParsedRequest() req: CrudRequest,\n  ): Promise&lt;void | T&gt;;\n}\n</code></pre> <p>Since all composed methods have <code>Base</code> ending in their names, overriding those endpoints could be done in two ways:</p> <ol> <li> <p>Attach <code>@Override()</code> decorator without any argument to the newly created method wich name doesn't contain <code>Base</code> ending. So if you want to override <code>getManyBase</code>, you need to create <code>getMany</code> method.</p> </li> <li> <p>Attach <code>@Override('getManyBase')</code> decorator with passed base method name as an argument if you want to override base method with a function that has a custom name.</p> </li> </ol> <p>Example:</p> <pre><code>...\nimport {\n  Crud,\n  CrudController,\n  Override,\n  CrudRequest,\n  ParsedRequest,\n  ParsedBody,\n  CreateManyDto,\n} from '@ihelpee/crud';\n\n@Crud({\n  model: {\n    type: Hero,\n  }\n})\n@Controller('heroes')\nexport class HeroesCrud implements CrudController&lt;Hero&gt; {\n  constructor(public service: HeroesService) {}\n\n  get base(): CrudController&lt;Hero&gt; {\n    return this;\n  }\n\n  @Override()\n  getMany(\n    @ParsedRequest() req: CrudRequest,\n  ) {\n    return this.base.getManyBase(req);\n  }\n\n  @Override('getOneBase')\n  getOneAndDoStuff(\n    @ParsedRequest() req: CrudRequest,\n  ) {\n    return this.base.getOneBase(req);\n  }\n\n  @Override()\n  createOne(\n    @ParsedRequest() req: CrudRequest,\n    @ParsedBody() dto: Hero,\n  ) {\n    return this.base.createOneBase(req, dto);\n  }\n\n  @Override()\n  createMany(\n    @ParsedRequest() req: CrudRequest,\n    @ParsedBody() dto: CreateManyDto&lt;Hero&gt;\n  ) {\n    return this.base.createManyBase(req, dto);\n  }\n\n  @Override('updateOneBase')\n  coolFunction(\n    @ParsedRequest() req: CrudRequest,\n    @ParsedBody() dto: Hero,\n  ) {\n    return this.base.updateOneBase(req, dto);\n  }\n\n  @Override('replaceOneBase')\n  awesomePUT(\n    @ParsedRequest() req: CrudRequest,\n    @ParsedBody() dto: Hero,\n  ) {\n    return this.base.replaceOneBase(req, dto);\n  }\n\n  @Override()\n  async deleteOne(\n    @ParsedRequest() req: CrudRequest,\n  ) {\n    return this.base.deleteOneBase(req);\n  }\n}\n</code></pre> <p>Notice: new custom route decorators were created to simplify process: <code>@ParsedRequest()</code> and <code>@ParsedBody()</code>. But you still can add your param decorators to any of the methods, e.g. <code>@Param()</code>, <code>@Session()</code>, etc. Or any of your own cutom route decorators.</p>"},{"location":"controllers/#adding-routes","title":"Adding routes","text":"<p>Sometimes you might need to add a new route and to use <code>@ParsedRequest()</code> in it. You need attach <code>CrudRequestInterceptor</code> in order to do that:</p> <pre><code>...\nimport { UseInterceptors } from '@nestjs/common';\nimport {\n  ParsedRequest,\n  CrudRequest,\n  CrudRequestInterceptor,\n} from '@ihelpee/crud';\n...\n\n@UseInterceptors(CrudRequestInterceptor)\n@Get('/export/list.xlsx')\nasync exportSome(@ParsedRequest() req: CrudRequest) {\n  // some awesome feature handling\n}\n</code></pre>"},{"location":"controllers/#additional-decorators","title":"Additional decorators","text":"<p>There are two additional decorators that come out of the box: <code>@Feature()</code> and <code>@Action()</code>. You can use them with your ACL implementation. <code>@Action()</code> will be applyed automaticaly on controller compoesd base methods. There is <code>CrudActions</code> enum that you can import and use:</p> <pre><code>enum CrudActions {\n  ReadAll = 'Read-All',\n  ReadOne = 'Read-One',\n  CreateOne = 'Create-One',\n  CreateMany = 'Create-Many',\n  UpdateOne = 'Update-One',\n  ReplaceOne = 'Replace-One',\n  DeleteOne = 'Delete-One',\n}\n</code></pre> <p><code>ACLGuard</code> dummy example with helper functions <code>getFeature</code> and <code>getAction</code>:</p> <pre><code>import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { getFeature, getAction } from '@ihelpee/crud';\n\n@Injectable()\nexport class ACLGuard implements CanActivate {\n  canActivate(ctx: ExecutionContext): boolean {\n    const handler = ctx.getHandler();\n    const controller = ctx.getClass();\n\n    const feature = getFeature(controller);\n    const action = getAction(handler);\n\n    console.log(`${feature}-${action}`); // e.g. 'Heroes-Read-All'\n\n    return true;\n  }\n}\n</code></pre>"},{"location":"requests/","title":"Requests","text":""},{"location":"requests/#description","title":"Description","text":"<p>Ihelpee/crud provides a full range of path and query parameters parsing/validation to help you build rich RESTful APIs. @ihelpee/crud-request is responsible for that.</p>"},{"location":"requests/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Query params</li> <li>select</li> <li>search</li> <li>filter conditions</li> <li>filter</li> <li>or</li> <li>sort</li> <li>join</li> <li>limit</li> <li>offset</li> <li>page</li> <li>cache</li> <li>Frontend usage</li> <li>Customize</li> <li>Usage</li> </ul>"},{"location":"requests/#query-params","title":"Query params","text":"<p>By default, we support these param names:</p> <p><code>fields</code>, <code>select</code> - get selected fields in GET result</p> <p><code>s</code> - search conditions (<code>$and</code>, <code>$or</code> with all possible variations)</p> <p><code>filter</code> - filter GET result by <code>AND</code> type of condition</p> <p><code>or</code> - filter GET result by <code>OR</code> type of condition</p> <p><code>join</code> - receive joined relational resources in GET result (with all or selected fields)</p> <p><code>sort</code> - sort GET result by some <code>field</code> in <code>ASC | DESC</code> order</p> <p><code>per_page</code>, <code>limit</code> - limit the amount of received resources</p> <p><code>offset</code> - offset some amount of received resources</p> <p><code>page</code> - receive a portion of limited amount of resources</p> <p><code>cache</code> - reset cache (if was enabled) and receive resources directly from the DB</p> <p>Notice: You can easily map your own query params names and chose another string delimiters by applying global options.</p> <p>Here is the description of each of those using default params names:</p>"},{"location":"requests/#select","title":"select","text":"<p>Selects fields that should be returned in the reponse body.</p> <p>Syntax:</p> <p>?fields=field1,field2,...</p> <p>Example:</p> <p>?fields=email,name</p>"},{"location":"requests/#search","title":"search","text":"<p>Adds a search condition as a JSON string to you request. You can combine <code>$and</code>, <code>$or</code> and <code>$not</code> and use any condition you need. Make sure it's being sent encoded or just use <code>RequestQueryBuilder</code></p> <p>Syntax:</p> <p>?s={\"name\": \"Michael\"}</p> <p>Some examples:</p> <ul> <li>Search by field <code>name</code> that can be either <code>null</code> OR equals <code>Superman</code></li> </ul> <p>?s={\"name\": {\"\\$or\": {\"\\$isnull\": true, \"\\$eq\": \"Superman\"}}}</p> <ul> <li>Search an entity where <code>isActive</code> is <code>true</code> AND <code>createdAt</code> not equal <code>2008-10-01T17:04:32</code></li> </ul> <p>?s={\"\\$and\": [{\"isActive\": true}, {\"createdAt\": {\"$ne\": \"2008-10-01T17:04:32\"}}]}</p> <p>...which is the same as:</p> <p>?s={\"isActive\": true, \"createdAt\": {\"\\$ne\": \"2008-10-01T17:04:32\"}}</p> <ul> <li>Search an entity where <code>isActive</code> is <code>false</code> OR <code>updatedAt</code> is not <code>null</code></li> </ul> <p>?s={\"\\$or\": [{\"isActive\": false}, {\"updatedAt\": {\"$notnull\": true}}]}</p> <ul> <li>Search an entity where condition is negated</li> </ul> <p>?s={\"\\$not\": [{\"\\$or\": [{\"isActive\": false}, {\"updatedAt\": {\"\\$notnull**\": true}}]}]}</p> <p>So the amount of combinations is really huge.</p> <p>Notice: if search query param is present, then filter and or query params will be ignored.</p>"},{"location":"requests/#filter-conditions","title":"filter conditions","text":"<ul> <li><code>$eq</code> (<code>=</code>, equal)</li> <li><code>$ne</code> (<code>!=</code>, not equal)</li> <li><code>$gt</code> (<code>&gt;</code>, greater than)</li> <li><code>$lt</code> (<code>&lt;</code>, lower that)</li> <li><code>$gte</code> (<code>&gt;=</code>, greater than or equal)</li> <li><code>$lte</code> (<code>&lt;=</code>, lower than or equal)</li> <li><code>$starts</code> (<code>LIKE val%</code>, starts with)</li> <li><code>$ends</code> (<code>LIKE %val</code>, ends with)</li> <li><code>$cont</code> (<code>LIKE %val%</code>, contains)</li> <li><code>$excl</code> (<code>NOT LIKE %val%</code>, not contains)</li> <li><code>$in</code> (<code>IN</code>, in range, accepts multiple values)</li> <li><code>$notin</code> (<code>NOT IN</code>, not in range, accepts multiple values)</li> <li><code>$isnull</code> (<code>IS NULL</code>, is NULL, doesn't accept value)</li> <li><code>$notnull</code> (<code>IS NOT NULL</code>, not NULL, doesn't accept value)</li> <li><code>$between</code> (<code>BETWEEN</code>, between, accepts two values)</li> <li><code>$eqL</code> (<code>LOWER(field) =</code>, equal)</li> <li><code>$neL</code> (<code>LOWER(field) !=</code>, not equal)</li> <li><code>$startsL</code> (<code>LIKE|ILIKE val%</code>)</li> <li><code>$endsL</code> (<code>LIKE|ILIKE %val</code>, ends with)</li> <li><code>$contL</code> (<code>LIKE|ILIKE %val%</code>, contains)</li> <li><code>$exclL</code> (<code>NOT LIKE|ILIKE %val%</code>, not contains)</li> <li><code>$inL</code> (<code>LOWER(field) IN</code>, in range, accepts multiple values)</li> <li><code>$notinL</code> (<code>LOWER(field) NOT IN</code>, not in range, accepts multiple values)</li> </ul>"},{"location":"requests/#filter","title":"filter","text":"<p>Adds fields request condition (multiple conditions) to your request.</p> <p>Syntax:</p> <p>?filter=field||\\$condition||value</p> <p>?join[]=relation&amp;filter=relation.field||\\$condition||value</p> <p>Notice: Using nested filter shall join relation first.</p> <p>Examples:</p> <p>?filter=name||\\$eq||batman</p> <p>?filter=isVillain||\\$eq||false&amp;filter=city||\\$eq||Arkham (multiple filters are treated as a combination of <code>AND</code> type of conditions)</p> <p>?filter=shots||\\$in||12,26 (some conditions accept multiple values separated by commas)</p> <p>?filter=power||\\$isnull (some conditions don't accept value)</p>"},{"location":"requests/#or","title":"or","text":"<p>Adds <code>OR</code> conditions to the request.</p> <p>Syntax:</p> <p>?or=field||\\$condition||value</p> <p>It uses the same filter conditions.</p> <p>Rules and examples:</p> <ul> <li>If there is only one <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li> </ul> <p>?or=name||\\$eq||batman</p> <ul> <li>If there are multiple <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:   <code>WHERE {or} OR {or} OR ...</code></li> </ul> <p>?or=name||\\$eq||batman&amp;or=name||\\$eq||joker</p> <ul> <li>If there are one <code>or</code> and one <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:   <code>WHERE {filter} OR {or}</code></li> </ul> <p>?filter=name||\\$eq||batman&amp;or=name||\\$eq||joker</p> <ul> <li>If present both <code>or</code> and <code>filter</code> in any amount (one or miltiple each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:   <code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li> </ul> <p>?filter=type||\\$eq||hero&amp;filter=status||\\$eq||alive&amp;or=type||\\$eq||villain&amp;or=status||\\$eq||dead</p>"},{"location":"requests/#sort","title":"sort","text":"<p>Adds sort by field (by multiple fields) and order to query result.</p> <p>Syntax:</p> <p>?sort=field,ASC|DESC</p> <p>Examples:</p> <p>?sort=name,ASC</p> <p>?sort=name,ASC&amp;sort=id,DESC</p>"},{"location":"requests/#join","title":"join","text":"<p>Receive joined relational objects in GET result (with all or selected fields). You can join as many relations as allowed in your CrudOptions.</p> <p>Syntax:</p> <p>?join[]=relation</p> <p>?join[]=relation||field1,field2,...</p> <p>?join[]=relation1||field11,field12,...&amp;join[]=relation1.nested||field21,field22,...&amp;join[]=...</p> <p>Examples:</p> <p>?join[]=profile</p> <p>?join[]=profile||firstName,email</p> <p>?join[]=profile||firstName,email&amp;join[]=notifications||content&amp;join[]=tasks</p> <p>?join[]=relation1&amp;join[]=relation1.nested&amp;join[]=relation1.nested.deepnested</p> <p>Notice: primary field/column always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.</p>"},{"location":"requests/#new-feature-join-condition-on-clause","title":"New Feature: Join Condition (on clause)","text":"<p>The join parameter now supports specifying a WHERE condition within the ON clause of the join using the on property. This allows for more granular control over the joined data.</p> <p>?join[]=relation||field1,field2,...||on[0]=field||\\$condition||value,on[1]=field||\\$condition...&amp;join[]=...</p> <p>Examples:</p> <p>Suppose you want to retrieve <code>Posts</code> along with their associated <code>Author</code> data, but you only want to include <code>Authors</code> where the <code>isActive</code> field is <code>true</code> and the <code>profilePicture</code> field is <code>null</code> (meaning the author doesn't have a profile picture set). You can achieve this with the following query string:</p> <p>?join[]=author||fullName,email||on[0]=author.isActive||\\$eq||true&amp;on[1]=author.profilePicture||\\$isnull</p> <p>This query will join the <code>Post</code> entity with its related <code>Author</code> entity, but it will only include <code>Author</code> objects where:</p> <ul> <li>The <code>isActive</code> field is set to <code>true</code>.</li> <li>The <code>profilePicture</code> field is <code>null</code>.</li> </ul>"},{"location":"requests/#limit","title":"limit","text":"<p>Receive <code>N</code> amount of entities.</p> <p>Syntax:</p> <p>?limit=number</p> <p>Example:</p> <p>?limit=10</p>"},{"location":"requests/#offset","title":"offset","text":"<p>Limit the amount of received resources</p> <p>Syntax:</p> <p>?offset=number</p> <p>Example:</p> <p>?offset=10</p>"},{"location":"requests/#page","title":"page","text":"<p>Receive a portion of limited amount of resources.</p> <p>Syntax:</p> <p>?page=number</p> <p>Example:</p> <p>?page=2</p>"},{"location":"requests/#cache","title":"cache","text":"<p>Reset cache (if was enabled) and receive resources directly from the DB.</p> <p>Usage:</p> <p>?cache=0</p>"},{"location":"requests/#frontend-usage","title":"Frontend usage","text":"<p>@ihelpee/crud-request is a framework agnostic package that has been designed for both backend and frontend usage. It's also used by @ihelpee/crud package in <code>CrudRequestInterceptor</code>.</p> <p>It has <code>RequestQueryBuilder</code> class that helps building a query string and customizing your query params names and delimiters.</p>"},{"location":"requests/#customize","title":"Customize","text":"<p>It has a static method <code>setOptions</code> that alows you to set different params names (defaults are shown):</p> <pre><code>import { RequestQueryBuilder } from '@ihelpee/crud-request';\n\nRequestQueryBuilder.setOptions({\n  delim: '||',\n  delimStr: ',',\n  paramNamesMap: {\n    fields: ['fields', 'select'],\n    search: 's',\n    filter: ['filter[]', 'filter'],\n    or: ['or[]', 'or'],\n    join: ['join[]', 'join'],\n    sort: ['sort[]', 'sort'],\n    limit: ['per_page', 'limit'],\n    offset: ['offset'],\n    page: ['page'],\n    cache: ['cache'],\n  },\n});\n</code></pre>"},{"location":"requests/#usage","title":"Usage","text":"<p>You can compose a query string in a chaining methods manner:</p> <pre><code>import { RequestQueryBuilder, CondOperator } from \"@ihelpee/crud-request\";\n\nconst qb = RequestQueryBuilder.create();\n\n// set search\n\nqb.search({\n  $or: [\n    {\n      foo: {\n        $notnull: true\n      },\n      baz: 1\n    },\n    {\n      bar: {\n        $ne: \"test\"\n      }\n    }\n  ]\n});\n\n// is actually the same as:\n\nqb.setFilter({ field: \"foo\", operator: CondOperator.NOT_NULL })\n  .setFilter({ field: \"baz\": operator: \"$eq\", value: 1 })\n  .setOr({\n    field: \"bar\",\n    operator: CondOperator.NOT_EQUALS,\n    value: \"test\"\n  });\n\nqb.select(['foo', 'bar'])\n  .setJoin({ field: 'company' })\n  .setJoin({ field: 'profile', select: ['name', 'email'] })\n  .setJoin({\n    field: 'boo',\n    select: ['status', 'date'],\n    on: [\n      { field: 'bar', operator: 'eq', value: 100 },\n      { field: 'baz', operator: 'isnull' },\n    ],\n  })\n  .sortBy({ field: 'bar', order: 'DES\u0421' })\n  .setLimit(20)\n  .setPage(3)\n  .resetCache()\n  .query();\n</code></pre> <p>Or, you can path all params to the <code>create</code> method:</p> <pre><code>const queryString = RequestQueryBuilder.create({\n  fields: ['name', 'email'],\n  search: { isActive: true },\n  join: [{ field: 'company' }],\n  sort: [{ field: 'id', order: 'DESC' }],\n  page: 1,\n  limit: 25,\n  resetCache: true,\n}).query();\n</code></pre>"},{"location":"service-typeorm/","title":"ServicesTypeorm","text":"<p>This package provides a CRUD service for relational databases build with TypeORM</p>"},{"location":"service-typeorm/#install","title":"Install","text":"<pre><code>yarn add @ihelpee/crud-typeorm @nestjs/typeorm typeorm\n</code></pre>"},{"location":"service-typeorm/#usage","title":"Usage","text":"<p>Assume you have some TypeORM entity:</p> <pre><code>import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';\n\n@Entity()\nexport class Company {\n  @PrimaryGeneratedColumn() id: number;\n\n  @Column() name: string;\n}\n</code></pre> <p>Then you need to create a service:</p> <pre><code>import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { TypeOrmCrudService } from '@ihelpee/crud-typeorm';\n\nimport { Company } from './company.entity';\n\n@Injectable()\nexport class CompaniesService extends TypeOrmCrudService&lt;Company&gt; {\n  constructor(@InjectRepository(Company) repo) {\n    super(repo);\n  }\n}\n</code></pre> <p>After that you need to provide your service in a controller:</p> <pre><code>import { Controller } from '@nestjs/common';\nimport { Crud, CrudController } from '@ihelpee/crud';\n\nimport { Company } from './company.entity';\nimport { CompaniesService } from './companies.service';\n\n@Crud({\n  model: {\n    type: Company,\n  },\n})\n@Controller('companies')\nexport class CompaniesController implements CrudController&lt;Company&gt; {\n  constructor(public service: CompaniesService) {}\n}\n</code></pre>"},{"location":"services/","title":"Services","text":""},{"location":"services/#description","title":"Description","text":"<p>Ihelpee/crud was designed to support any ORM and any DB.</p> <p>Here is the list of supported ORMs and those that are going to be implemented in the nearest future:</p> <ul> <li>[x] TypeORM - @ihelpee/crud-typeorm - docs</li> <li>[ ] Mongoose - PR welcome</li> <li>[ ] Sequelize - PR welcome</li> </ul>"}]}